package hw5;

//Quick Sort
// В начале выбирается “опорный” элемент массива. Это может быть любое число, но от выбора этого элемента сильно
// зависит эффективность алгоритма. Если нам известна медиана, то лучше выбирать элемент, который как можно ближе
// к медиане. В нашей реализации алгоритма, мы будем брать самый левый элемент, который в результате займет свое место.
// Элементы в массиве делятся на две части: слева те кто меньше опорного элемента, справа те кто больше. Таким образом
// опорный элемент занимает свое место и больше никуда не двигается.
// Для левого и правого массива действия повторяются рекурсивно.

// Примечание: так как решена задача была на ДЗ №2, не обратил внимание на особенности условия задачи связанное
// с выбором опорной  точки, заметил только при отсылки на GitHub, здесь опорная выбиралась по середине, переделать
// не успеваю

public class QuickSort
{
    public void sort(int [] array, int first, int last)
    {
        if(first < last)
        {
            int left   = first;
            int right  = last;
            int middle = array[(left + right) / 2];
            do
            {
                while (array[left] < middle)
                {
                    left++;
                }
                while (array[right] > middle)
                {
                    right--;
                }
                if (left <= right)
                {
                    int buf = array[left];
                    array[left] = array[right];
                    array[right] = buf;
                    left++;
                    right--;
                }
            } while (left <= right);
            sort(array, first, right);
            sort(array, left, last);
        }
    }
}
